---
title: "Outbreak Detection"
output: html_document
date: "2024-11-04"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```


## Expected learning outcomes

By the end of this session, participants should be able to:

- understand the basics principles of outbreak detection including creating and expectation, threshold and alarm

- implement & apply different outbreak detection methods to time series with different characteristics and understand advantages and disadvantages of different methods

- get to know the SignalDetectionTool and apply it to a real dataset to identify outbreaks

## Preparations

Required source code to load.

```{r, include = TRUE, source-Rscript}
source("source_outbreak_det.R")
```

Required packages

```{r, load-packages, include = TRUE}
library(dplyr)
library(ggplot2)
library(SignalDetectionTool)
```

# Section 1: Implement your first outbreak detection algorithm

We will now import the first data set to analyse.

```{r, load-dataset}
ts1 <- readRDS("data/sim3.Rds")
```

## Task 1.1 
Visualise the first time series ts0 using the function `plot_ts()` which is provided in the source_outbreak_det.R script.
What do you observe? What characteristics does this time series have? Do you see any potential outbreaks?

```{r, vis-dataset-task-1.1}
plot_ts(ts1)
```


Seasonal structure. Outbreak at the end and potentially also in summer 2019.

## Task 1.2

We want to apply a simple outbreak detection method to the last time point of this time series.
The baseline/expectation should be the mean of all observations before current time point. Fill in the blanks to obtain the baseline and plot the time series together with the baseline.

```{r, outbreak-detection-algo-task-1.2}
# split the data set
# data points we use for model fitting, i.e. we build our expectation on are all except the last one
fit_data <- ts1 %>% head(-1)
# the last data point we want to do signal detection for
pred_data <- ts1 %>% tail(1)

# fit the model
model <- glm(formula = cases ~ 1, data = fit_data, family = poisson())
# we generate an expectation for visualisation purposes for the data used for fitting
# model$fitted.values give the expected values based on the model already transformed using exp() (see documentation)
fit_data <- fit_data %>% 
  mutate(
    expectation = model$fitted.values
    )

# based on the model make predictions for the last data point which we want to do signal detection for
pred <- predict.glm(model, newdata = pred_data)

pred_data <- pred_data %>%
  mutate(
    expectation = exp(pred)
    )

# combine the two data sets back together
data_with_baseline <- bind_rows(fit_data, pred_data)
```

**Note and advice for facilitators:**  

We are not talking about bias in the computed expectation due to past outbreaks in the time series because we did not want to add this level of complexity to the practical. If fellows realise or ask that the expectation is biased upwards due to past outbreaks you can tell them that this observation is correct and that this is taken care of in a lot of the typically used algorithms (i.e. weighted regression applied in FarringtonFlexible or an easier method is to remove those past outbreaks from the data). In this practical we ignore this problem to keep it simple. 


## Task 1.3

Now plot the time series with expectation using `plot_ts()`. Does what you observe match your expectations? Do you think this is a good fit?

```{r,apply-detect-outbreaks-task-1.3}

plot_ts(data_with_baseline)

```


Observations:
We see a constant average as computed expectation. The expectation did average out the low and high season. We do not think that this baseline fits our timeseries well. 

## Task 1.4

In the next step we calculate a threshold based on the 95% quantile of the Poisson distribution around the expected value of the last data point and add it to our pred_data. For visualisation purpose we also extend the threshold into the past.
Please fill all the spots with ____ to make the code work.

```{r, threshold-1.4}
fit_data <- fit_data %>%
  mutate(
    threshold = qpois(0.95,expectation)
    )

pred_data <- pred_data %>%
  mutate(
    threshold = qpois(0.95,expectation)
    )

# bind fit and pred data together

data_with_baseline_and_threshold <- bind_rows(fit_data, pred_data)
```

Please plot the time series with the expectation and the threshold. 

```{r, plot_baseline_threshold-1.4}
plot_ts(data_with_baseline_and_threshold)

```

## Task 1.5

Lastly we want to generate signals. Signals are those case numbers that exceed the threshold. As we are performing outbreak detection for the last time point we only want to generate a signal for this time point. Please fill the blanks to add a signal to the pred_data.

```{r, signals-1.5}

pred_data <- pred_data %>% mutate(alarms = pred_data$cases > threshold)

# bind results together
data_with_signals <- bind_rows(fit_data, pred_data)
  
```

## Task 1.6
Now we plot all elements we computed for the outbreak detection. Do you think this algorithm is suited for this timeseries? 
Do you have any suggestions for improvement? Discuss.

```{r, plot_ts_signals-1.6}

plot_ts(data_with_signals)

```

No signal was generated as the case number is below the threshold. This method is not suited for this seasonal timeseries as it does not capture this feature would miss outbreaks in the low season and would often classify the peak of the season as an outbreak.

# Section 2: Improve the algorithm 

## Task 2.1

Improve the algorithm, have a look at the variables available in ts1. Please fill the gaps to implement the new algorithm. This time we directly compute the threshold and alarms as well in one step. 

**Note for facilitators**: We remove all objects from the previous model from the environment so that the fellows start with a fresh environment and there is no confusion, i.e. the object already exists but it was actually not created in this section but before.
```{r, improve_outbreak_det_method-2.1}
# first we make a fresh environment
rm(fit_data, pred_data, model, data_with_signals, envir = .GlobalEnv)

# split the data set
# data points we use for model fitting, i.e. we build our expectation on are all except the last one
fit_data <- ts1 %>% head(-1)
# the last data point we want to do signal detection for
pred_data <- ts1 %>% tail(1)

# fit the model
model <- glm(formula = cases ~ 1 + sin + cos, data = fit_data, family = poisson())
# we generate an expectation for visualisation purposes for the data used for fitting
# model$fitted.values give the expected values based on the model already transformed using exp() (see documentation)
fit_data <- fit_data %>% 
  mutate(
    expectation = model$fitted.values,
    threshold = qpois(0.95,expectation)
    )

# based on the model make predictions for the last data point which we want to do signal detection for
pred <- predict.glm(model, newdata = pred_data)

pred_data <- pred_data %>%
  mutate(
    expectation = exp(pred),
    threshold = qpois(0.95,expectation),
    alarms = pred_data$cases > threshold
    )

# combine the two data sets back together
data_with_signals <- bind_rows(fit_data, pred_data)

```

Please plot the result and discuss what you see.

```{r, plot_improved_method-2.1}

plot_ts(data_with_signals)

```

Algorithm including seasonality fits better and the last time point is now correctly identified as outbreak.

# Section 3: Optional Task 
We want to do signal detection on another time series with different characteristics. Please plot the time series and describe it.

```{r, ts2-3.1}
# read in the time series 2
ts2 <- readRDS("data/sim2.Rds")

# Plot the time series 2
plot_ts(ts2)

```

Downward time trend in the timeseries. Outbreak in the end.

## Task 3.2

Think about a suitable model you would use to do outbreak detection for this time series and fill the gaps.
**Advice for facilitators:**: If fellows struggle, then you can give a hint that they can look at the variables inside the ts2 dataset. There is a variable time that can be used to model a timetrend.

```{r, ts2_signal_detection_3.2}
# first we make a fresh environment
rm(fit_data, pred_data, model, data_with_signals, envir = .GlobalEnv)

# split the data set
# data points we use for model fitting, i.e. we build our expectation on are all except the last one
fit_data <- ts2 %>% head(-1)
# the last data point we want to do signal detection for
pred_data <- ts2 %>% tail(1)

# fit the model
model <- glm(formula = cases ~ 1 + time, data = fit_data, family = poisson())
# we generate an expectation for visualisation purposes for the data used for fitting
# model$fitted.values give the expected values based on the model already transformed using exp() (see documentation)
fit_data <- fit_data %>% 
  mutate(
    expectation = model$fitted.values,
    threshold = qpois(0.95,expectation)
    )

# based on the model make predictions for the last data point which we want to do signal detection for
pred <- predict.glm(model, newdata = pred_data)

pred_data <- pred_data %>%
  mutate(
    expectation = exp(pred),
    threshold = qpois(0.95,expectation),
    alarms = pred_data$cases > threshold
    )

# combine the two data sets back together
data_with_signals <- bind_rows(fit_data, pred_data)

```

We build a model using a linear time trend. 

## Task 3.3
Plot your results and describe what you observe.

```{r, ts2_signal_detection_plot_3.3}

plot_ts(data_with_signals)

```

We fitted a model with a decreasing time trend and are able to detect the outbreak at the end of the time series.

# Section 4: Investigate the ESTEC outbreak in Germany 2025 using the SignalDetectionTool

You are the epidemiologist who is in charge of investigating whether there is an ESTEC outbreak going on in Germany and in which subgroups of the population this outbreak is taking place. Apply the SignalDetectionTool to the ESTEC Dataset from Germany in 2025 and find out more about case numbers and which subgroups are affected. Play around with different settings and try to understand the results which are shown in the app.

If you were not able to install the SignalDetectionTool you can use our generated HTML reports instead.  

